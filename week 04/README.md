## Едномерни масиви

### Дефиниция на едномерен масив
**Свойства:**
- поредица от определен брой стойности с еднакъв тип 
- индексация на елементите, започвайки от `0` до `size - 1`
- пряк достъп до елементите чрез оператор []
- възможност за инициализация на елементите чрез конструктор

**Дефиниция:**
<тип> <име>[<размер>];
<тип> <име>[<размер>] = {<стойности>};

*Примери:* 
```c++
int a[5];
int b[5] = {1, 2, 3};
```

<име>[<индекс>] = <стойност>;

*Примери:* 
```c++
a[0] = 2;
int x = a[3];
```

>  **Съвети за качествен код:**
> - масив се дефинира само с константен размер
> - препоръчва се използването на тип `size_t` за размерност

#### Tips & Tricks:
| <div style="width:100px" />           |  <div style="width:175px" /> Грешно     |  <div style="width:250px" />  Правилно | Защо?       |
| --------- | ----------- | --------- | ----------- |
| Дефиниция на масив                     | size_t n; <br> std::cin >> n; <br> int array[n]; | const size_t n = 128; <br> int array[n]; | Макар повечето съвременни компилатори да се справят с неконстантна инициализация, това е недобре дефинирано поведение и не се препоръчва. 

### Сортиращи алгоритми

**Условие:** Да се сортира в нарастващ ред масив array, съставен от N на брой цели числа.

#### Метод на пряката селекция

```c++
// обхождат се всики позиции
for (size_t i = 0; i < N; ++i) {
    // обхождат се елементите, намиращи се вдясно от текущата позиция
    for (size_t j = i + 1; j < N; ++j) {
        // ако се намери транспозиция между елементи
        // т.е. елемент, разположен вдясно от текущия, да е по-малък от него
        if (array[i] > array[j]) {
            // елементите се разменят
            std::swap(array[i], array[j]);
        }
    }

    // на i-тата позиция се намира i-тият пореден елемен в нарастващ ред
}
```

#### Метод на мехурчето
```c++
// променлива, която следи дали масивът е сортиран (започва от лъжа)
bool sorted = false;

// докато масивът не е сортиран
while (!sorted) {
    // приема се, че е сортиран
    sorted = true;

    // обхождат се всички елементи, започвайки от индекс 1
    // т.е. пропуска се първият елемент
    for (size_t i = 1; i < N; ++i) {
        // ако се намери транспозиция между текущия и предишния елемент
        if (array[i - 1] > array[i]) {
            // те се разменят
            std::swap(array[i - 1], array[i]);
            // и масивът се отбелязва за несортиран
            sorted = false;
        }
    }
}
```

### Алгоритми за търсене

**Условие:** Да се намери позицията на елемента X в сортиран в нарастващ ред масив array, съдържащ N на брой цели числа.

#### Двоично търсене

```c++
// в началото се разглежда целия масив
size_t start = 0, end = N;
// за позиция се определя невалидна стойност 
int position = -1;

// докато в разглежданият отрязък има поне един елемент
// и позицията е невалидна, т.е. елементът не е намерен
while (start < end && position == -1) {
    // намира се средният индекс за разглежданият отрязък
    size_t middle = (start + end) / 2;

    // ако елементът на този индекс е равен на търсения
    if (array[middle] == X) {
        // то търсеният елемент е намерен
        // и се отбелязва позицията му
        position = middle;
    }
    // ако елементът на този индекс е по-малък от търсения
    else if (array[middle] < X) {
        // при следваща итерация се разглежда дясната част на текущия отрязък
        start = middle + 1;
    } 
    // ако елементът на този индекс е по-голям от търсения
    // при следваща итерация се разглежда лявата част на текущия отрязък
    else end = middle;
}
```
