## Едномерни масиви

### Дефиниция на едномерен масив
**Свойства:**
- поредица от определен брой стойности с еднакъв тип 
- индексация на елементите, започвайки от `0` до `size - 1`
- пряк достъп до елементите чрез оператор []
- възможност за инициализация на елементите чрез конструктор

**Дефиниция:**
<тип> <име>[<размер>];
<тип> <име>[<размер>] = {<стойности>};

*Примери:* 
```c++
int a[5];
int b[5] = {1, 2, 3};
```

<име>[<индекс>] = <стойност>;

*Примери:* 
```c++
a[0] = 2;
int x = a[3];
```

>  **Съвети за качествен код:**
> - масив се дефинира само с константен размер
> - препоръчва се използването на тип `size_t` за размерност

#### Tips & Tricks:
| <div style="width:100px" />           |  <div style="width:175px" /> Грешно     |  <div style="width:250px" />  Правилно | Защо?       |
| --------- | ----------- | --------- | ----------- |
| Дефиниция на масив                     | size_t n; <br> std::cin >> n; <br> int array[n]; | const size_t n = 128; <br> int array[n]; | Макар повечето съвременни компилатори да се справят с неконстантна инициализация, това е недобре дефинирано поведение и не се препоръчва. 

---

### Сортиращи алгоритми

**Условие:** Да се сортира в нарастващ ред масив array, съставен от N на брой цели числа.

*Редица:* 4, 13, 5, 2, 6 <br>
*N*=5

#### Метод на пряката селекция

```c++
// обхождат се всики позиции
for (size_t i = 0; i < N - 1; ++i) {
    // обхождат се елементите, намиращи се вдясно от текущата позиция
    for (size_t j = i + 1; j < N; ++j) {
        // ако се намери транспозиция между елементи
        // т.е. елемент, разположен вдясно от текущия, да е по-малък от него
        if (array[i] > array[j]) {
            // елементите се разменят
            std::swap(array[i], array[j]);
        }
    }

    // на i-тата позиция се намира i-тият пореден елемен в нарастващ ред
}
```

##### Илюстрация 

i = 0
| *4*     | 13     | 5     | 2     | 6     | |
|---------|--------|-------|-------|-------|-|
| i       | j      |       |       |       | |
| i       |        | j     |       |       | |
| i       |        |       | j     |       | транспозиция; <br> разменят се 4 и 2 |
|         |        |       |       |       | |
| __*2*__ | __13__ | __5__ | __4__ | __6__ | |
| i       |        |       |       | j     | |

i = 1
| *2*     | *13*    | 5      | 4     | 6     | |
|---------|---------|--------|-------|-------|-|
|         | i       | j      |       |       | транспозиция; <br> разменят се 13 и 5 |
|         |         |        |       |       | |
| __*2*__ | __*5*__ | __13__ | __4__ | __6__ | |
|         | i       |        | j     |       | транспозиция; <br> разменят се 5 и 4 |
|         |         |        |       |       | |
| __*2*__ | __*4*__ | __13__ | __5__ | __6__ | |
|         | i       |        |       | j     | | 

i = 2
| *2*     | *4*     | *13*    | 5      | 6     | |
|---------|---------|---------|--------|-------|-|
|         |         | i       | j      |       | транспозиция; <br> разменят се 13 и 5 |
|         |         |         |        |       | |
| __*2*__ | __*4*__ | __*5*__ | __13__ | __6__ | |
|         |         | i       |        | j     | |

i = 3
| *2*     | *4*     | *5*    | *13*   | 6     | |
|---------|---------|--------|--------|-------|-|
|         |         |        | i      | j     | транспозиция; <br> разменят се 13 и 6 |

*Резултат:* 2, 4, 5, 6, 13

#### Метод на мехурчето
```c++
// променлива, която следи дали масивът е сортиран (започва от лъжа)
bool sorted = false;

// докато масивът не е сортиран
while (!sorted) {
    // приема се, че е сортиран
    sorted = true;

    // обхождат се всички елементи, започвайки от индекс 1
    // т.е. пропуска се първият елемент
    for (size_t i = 1; i < N; ++i) {
        // ако се намери транспозиция между текущия и предишния елемент
        if (array[i - 1] > array[i]) {
            // те се разменят
            std::swap(array[i - 1], array[i]);
            // и масивът се отбелязва за несортиран
            sorted = false;
        }
    }
}
```

##### Илюстрация 

**Итерация 1:** <br>
sorted: true
| 4     | 13     | 5      | 2      | 6     | |
|-------|--------|--------|--------|-------|-|
| i - 1 | i      |        |        |       | |
|       | i - 1  | i      |        |       | транспозиция; <br> разменят се 13 и 5; <br> sorted: false |
|       |        |        |        |       | |
| __4__ | __5__  | __13__ | __2__  | __6__ | |
|       |        | i - 1  | i      |       | транспозиция; <br> разменят се 13 и 2; <br> sorted: false |
|       |        |        |        |       | |
| __4__ | __5__  | __2__  | __13__ | __6__ | |
|       |        |        | i - 1  | i     | транспозиция; <br> разменят се 13 и 6; <br> sorted: false |

sorted: false

**Итерация 2:** <br>
sorted: true
| 4     | 5      | 2      | 6      | 13     | |
|-------|--------|--------|--------|--------|-|
| i - 1 | i      |        |        |        | |
|       | i - 1  | i      |        |        | транспозиция; <br> разменят се 5 и 2; <br> sorted: false |
|       |        |        |        |        | |
| __4__ | __2__  | __5__  | __6__  | __13__ | |
|       |        | i - 1  | i      |        | |
|       |        |        | i - 1  | i      | |

sorted: false

**Итерация 3:** <br>
sorted: true
| 4     | 2      | 5      | 6      | 13     | |
|-------|--------|--------|--------|--------|-|
| i - 1 | i      |        |        |        | транспозиция; <br> разменят се 4 и 2; <br> sorted: false |
|       |        |        |        |        | |
| __2__ | __4__  | __5__  | __6__  | __13__ | |
|       | i - 1  | i      |        |        | |
|       |        | i - 1  | i      |        | |
|       |        |        | i - 1  | i      | |

sorted: false

**Итерация 4:** <br>
sorted: true
| 2     | 4      | 5      | 6      | 13     | |
|-------|--------|--------|--------|--------|-|
| i - 1 | i      |        |        |        | |
|       | i - 1  | i      |        |        | |
|       |        | i - 1  | i      |        | |
|       |        |        | i - 1  | i      | |

sorted: true

*Резултат:* 2, 4, 5, 6, 13

### Алгоритми за търсене

**Условие:** Да се намери позицията на елемента X в сортиран в нарастващ ред масив array, съдържащ N на брой цели числа.

*Редица:* 2, 4, 5, 6, 13 <br>
*N*=5, *X*= 4

#### Двоично търсене

```c++
// в началото се разглежда целия масив
size_t start = 0, end = N;
// за позиция се определя невалидна стойност 
int position = -1;

// докато в разглежданият отрязък има поне един елемент
// и позицията е невалидна, т.е. елементът не е намерен
while (start < end && position == -1) {
    // намира се средният индекс за разглежданият отрязък
    size_t middle = (start + end) / 2;

    // ако елементът на този индекс е равен на търсения
    if (array[middle] == X) {
        // то търсеният елемент е намерен
        // и се отбелязва позицията му
        position = middle;
    }
    // ако елементът на този индекс е по-малък от търсения
    else if (array[middle] < X) {
        // при следваща итерация се разглежда дясната част на текущия отрязък
        start = middle + 1;
    } 
    // ако елементът на този индекс е по-голям от търсения
    // при следваща итерация се разглежда лявата част на текущия отрязък
    else end = middle;
}
```

##### Илюстрация 

**Итерация 1:**
|        | 2     | 4      | 5      | 6      | 13    | -   |
|--------|------ |--------|--------|--------|-------|-----|
| Индекс | 0     | 1      | 2      | 3      | 4     | 5   |
|        | start |        | middle |        |       | end |

 array[middle] == 5 > 4 == X

 **Итерация 2:**
|        | 2     | 4      | 5      | 6      | 13    | -   |
|--------|------ |--------|--------|--------|-------|-----|
| Индекс | 0     | 1      | 2      | 3      | 4     | 5   |
|        | start | middle | end    |        |       |     |


array[middle] == 4 == X => Position = 1


