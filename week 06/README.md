## Функции

### Дефиниция на функция
```
<тип> <име> (<списък с параметри>) {
    <тяло на функцията>
}
```

### Функции с тип на връщане
```
<тип> <име> (<списък с параметри>) {
    <тяло на функцията>

    return <резултат>
}
```

#### Пример 
**Задача:** Да се реализира функция, която връща огледалното на дадено число

```c++
int mirror(int number) {
    int mirrorNumber = 0;

    while (number > 0) {
        short digit = number % 10;
        number /= 10;

        mirror *= 10;
        mirror += digit;
    }

    return mirror;
}
```

### Функции без тип на връщане
- празен тип (void)
- липсва резултат от изпълнение

```
void <име> (<списък с параметри>) {
    <тяло на функцията>
}
```

#### Пример 
**Задача:** Да се реализира функция, която извежда на екрана N-тото число на Фибоначи

```c++
void fibonaciPrint(unsigned n) {
    unsigned f1 = 0, f2 = 1, f3;

    for (unsigned i = 2; i < n; ++i) {
        f3 = f1 + f2;
        f1 = f2;
        f2 = f3;
    }

    std::cout << f3 << std::endl;
}
```

#### Tips & Tricks:
| <div style="width:100px" />           |  <div style="width:175px" /> Грешно     |  <div style="width:250px" />  Правилно | Защо?       |
| --------- | ----------- | --------- | ----------- |
| Булев резултат на връщане | if ( <условие> ) { <br>	return true; <br> } else { <br>	return false; <br> } | return <условие>; | Всяко условие се оценява до булева стойност, съответно true или false. Когато се реализира функция с булев тип на връщане, тази оценка може да се използва директно и условният оператор може да бъде премахнат. 


## Указатели. Указателна аритметика

### Дефиниция
- Променлива, чиято стойност е адрес в паметта, съдържащ стойност от съответния тип
- Запазен символ __*__ след типа, означаващ указател от съответния тип
- Запазен символ __&__ преди името на променлива, служещ за извличане на адреса й 

```
<тип> <променлива> = <стойност>;
<тип>* <указател> = &<променлива>;
```

```c++
int a = 5;
int* ptr = &a;
```

### Масивите като указатели. Указателна промевлива

#### Tips & Tricks:
| <div style="width:100px" />           |  <div style="width:175px" /> Как     |  <div style="width:250px" />  Правилно | Защо?       |
| --------- | ----------- | --------- | ----------- |
| Масивите като указатели | Нека arr е масив. <br> arr[0] ⇔ *(arr) <br> arr[i] ⇔ *(arr + i) | Ако се наложи, елементите на масив могат да се достъпват чрез указателна аритметика. Това е възможно, защото променлива с име, съвпадащо с името на масив, всъщност е указател към първия (нулев) елемент на същия масив.


## Указатели като параметри на функция. Псевдоними



