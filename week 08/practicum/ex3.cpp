/*
 * Проверява дали даден символ е буква.
 * За опростяване приемаме латински букви: 'a'..'z', 'A'..'Z'.
 *
 * Връща:
 *   - true, ако символът е буква
 *   - false, в противен случай
 */
bool isLetter(char c)
{
    // 1. Проверяваме дали c е между 'a' и 'z'.
    // 2. Ако не е, проверяваме дали е между 'A' и 'Z'.
    // 3. Ако поне едно от условията е вярно, връщаме true.
    // 4. В противен случай връщаме false.
}

/*
 * Проверява дали даден символ е разделител на думи.
 * По условие разделителите са: интервал, '.', ',', '!', '?' и ':'.
 *
 * Връща:
 *   - true, ако символът е разделител
 *   - false, ако не е
 */
bool isWordSeparator(char c)
{
    // 1. Сравняваме c с ' ' (интервал), '.', ',', '!', '?' и ':'.
    // 2. Ако съвпада с някой от тези символи, връщаме true.
    // 3. В противен случай връщаме false.
}

/*
 * Зарежда нов текст от стандартния вход.
 *
 * Параметри:
 *   - text: референция към указател към текущия текст.
 *           Ако вече има стар текст (text != nullptr), той трябва да бъде изтрит.
 *   - length: референция към текущата дължина на текста.
 *
 *   - Ако има стар текст, го освобождава (delete[]).
 *   - Прочита дължина на текста от входа (size_t).
 *   - Заделя динамично масив от символи с дадения размер + 1 за '\0'.
 *   - Прочита текста (ред от конзолата) и го записва в масива.
 *   - Актуализира length с реалната дължина и гарантира, че текстът завършва с '\0'.
 */
void loadText(char *&text, std::size_t &length)
{
    // 1. Ако text не е nullptr:
    //      - освобождаваме старата памет (delete[] text).
    //      - задаваме text = nullptr и length = 0.
    //
    // 2. Прочитаме от стандартния вход желаната дължина на новия текст (или я приемаме
    //    по друг описан в условието начин).
    //
    // 3. Заделяме динамично масив от char с размер (дължина + 1).
    //
    // 4. Прочитаме текста от стандартния вход (например с getline), така че да
    //    позволяваме интервали в него.
    //
    // 5. Записваме указателя към новозделения масив в text.
    //
    // 6. Изчисляваме реалната дължина на текста (до '\0') и я записваме в length.
    //
    // 7. Уверяваме се, че последният символ е '\0'.
}

/*
 * Брои броя на думите в текста според дефиницията:
 * дума е низ от букви, без интервали или символи . , ! ? :
 * между тях.
 *
 * Параметри:
 *   - text: указател към текста (може да е nullptr).
 *   - length: дължината на текста.
 *
 * Връща:
 *   - броя на думите (size_t).
 *
 * Ако text == nullptr, функцията връща 0 и не прави нищо.
 */
std::size_t countWords(const char *text, std::size_t length)
{
    // 1. Ако text е nullptr или length == 0:
    //      - връщаме 0.
    //
    // 2. Инициализираме брояч на думите wordCount = 0.
    //
    // 3. Обхождаме текста от индекс i = 0 до i < length.
    //
    // 4. Прескачаме всички символи, които са разделители на думи
    //    (използваме isWordSeparator).
    //
    // 5. Ако стигнем до буква (isLetter(text[i]) == true):
    //      - това е начало на нова дума → увеличаваме wordCount.
    //      - после продължаваме да увеличаваме i, докато символите са букви,
    //        за да пропуснем цялата дума.
    //
    // 6. Ако символът не е нито разделител, нито буква (други символи),
    //    решаваме как да ги третираме – например като разделители.
    //
    // 7. Накрая връщаме wordCount.
}

/*
 * Премахва допълнителните интервали (последователни интервали) в текста.
 * Оставя само по един интервал между думи. Работи върху съществуващия масив.
 *
 * Параметри:
 *   - text: указател към текста (char*), който ще бъде променян "на място".
 *   - length: референция към дължината – може да се промени
 *             (ако махнем символи, новата дължина е по-малка).
 *
 * Ако text == nullptr, функцията не прави нищо.
 */
void removeExtraSpaces(char *text, std::size_t &length)
{
    // 1. Ако text е nullptr или length == 0:
    //      - прекратяваме функцията (не правим нищо).
    //
    // 2. Въвеждаме два индекса:
    //      - readIndex – от който четем символи от оригиналния текст.
    //      - writeIndex – на който записваме "почистените" символи.
    //
    // 3. Обхождаме текста:
    //      - Копираме текущия символ text[readIndex] към text[writeIndex].
    //
    //      - Ако символът НЕ е интервал:
    //            * просто увеличаваме readIndex и writeIndex.
    //
    //      - Ако символът Е интервал:
    //            * записваме един интервал на позиция writeIndex.
    //            * увеличаваме readIndex, докато следващите символи са интервали
    //              (така пропускаме всички допълнителни интервали).
    //            * увеличаваме writeIndex само веднъж (за един интервал).
    //
    // 4. След като приключим обхождането, поставяме '\0' след последния записан символ.
    //
    // 5. Актуализираме length така, че да съответства на новата дължина (до '\0').
}

/*
 * Изпечатва текста на стандартния изход.
 *
 * Параметри:
 *   - text: указател към текста (може да е nullptr).
 *   - length: дължината на текста.
 *
 * Ако text == nullptr, функцията не прави нищо.
 */
void printText(const char *text, std::size_t length)
{
    // 1. Ако text е nullptr или length == 0:
    //      - не печатаме нищо и просто се връщаме.
    //
    // 2. Обхождаме текста от 0 до length (или до '\0') и извеждаме
    //    символ по символ на стандартния изход.
    //
    // 3. Накрая извеждаме нов ред.
}

/*
 * Главна функция, която:
 *   - поддържа безкраен цикъл за четене на команди от стандартния вход,
 *   - според прочетения символ изпълнява съответната операция:
 *       '.' -> зарежда текст
 *       '#' -> брои думите и извежда броя
 *       '-' -> премахва допълнителните интервали
 *       '+' -> отпечатва текста
 *       'q' -> приключва програмата
 *
 *   - Ако няма зареден текст (text == nullptr), командите '#', '-', '+' не правят нищо.
 */
int main()
{
    // 1. Инициализираме:
    //      - char* text = nullptr;      // текущ текст
    //      - std::size_t length = 0;    // дължина на текущия текст
    //
    // 2. Влизаме в безкраен цикъл:
    //      - четем команда от стандартния вход (символ: char cmd).
    //
    // 3. Според стойността на cmd:
    //
    //      a) Ако cmd е '.':
    //           - извикваме loadText(text, length).
    //
    //      b) Ако cmd е '#':
    //           - ако text != nullptr:
    //                * извикваме countWords(text, length) и
    //                  отпечатваме върнатия резултат.
    //             иначе:
    //                * не правим нищо.
    //
    //      c) Ако cmd е '-':
    //           - ако text != nullptr:
    //                * извикваме removeExtraSpaces(text, length).
    //
    //      d) Ако cmd е '+':
    //           - ако text != nullptr:
    //                * извикваме printText(text, length).
    //
    //      e) Ако cmd е 'q':
    //           - прекъсваме цикъла (излизаме от програмата).
    //
    //      f) При други символи:
    //           - или ги игнорираме, или извеждаме съобщение за невалидна команда.
    //
    // 4. След излизане от цикъла:
    //      - ако text != nullptr, освобождаваме паметта (delete[] text).
    //
    // 5. Връщаме 0 като код за успешно приключване.
}