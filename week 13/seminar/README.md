### Задача 1

Наличен е следният алгоритъм за бързо повдигане на степен:
- Взима се цяло положително число a и степен p.
- Ако p е четно, намира се a на степен p/2 и резултатът се повдига на квадрат.
- Ако p е нечетно, намира се a на степен p - 1 и резултатът се умножава по а.

Да се напише функция, която приема числа a и p и връща като резултат a^p. Да се напише програма, която въвежда стойности за a и p, извиква функцията и извежда получения резултат. 

---

### Задача 2

Да се напише функция, която пресмята стойността на израз, формулиран чрез цели числа, знаци за събиране, изваждане, деление, умножение и повдигане на степен и скоби. Приоритет на операциите да НЕ се взима под внимание.

**Забележка:** Низът за израза е статично заделен и съдържат не повече от 128 символа. Изразът е коректно въведен, съдържащ единствено числата между 0 и 9, отварящи и затварящи скоби и операциите +, -, *, /.

### Пример:

**Вход:** 2+3*((1+4)*5)-7 <br>
**Изход:** 113

**Да се използва за основа следния код:**
В кода са допуснати грешки, които трябва да се отстранят.

```c++
const char OPEN = '(', CLOSE = ')';
const size_t STRLEN = 128;

void extractSubexpression(const char expr[], char output[]) {
    int openedBraces = 1;

    for (size_t i = 1; i < strlen(expr); ++i) {
        if (expr[i] == OPEN) openedBraces ++;
        else if (expr[i] == CLOSE) {
            openedBraces --;

            if (openedBraces == 0) {
                strncpy(output, expr + 1, i - 1);
                output[i - 1] = '\0';
            }
        }
        
    }

    strcpy(output, expr);
}

int calculate(int a, char op, int b) {
    switch(op) {}
}


void simplify(const char expr[]) {
    char simplified[STRLEN] = "";

    size_t index = 0;
    while (index < strlen(expr)) {
        if (expr[index] == OPEN) {
            extractSubexpression(expr + index, subexpr);
            toString(calculate(subexpr), output);
            strcat(simplified, output);

            index += strlen(subexpr) + 1;
        }
        else {
            strcat(simplified, expr[index]);
        }

        strcpy(expr, simplified);
    }

    return result;
}

int calculate(const char expr[]) {
    simplify(expr);

    size_t index = 0;
    while (index < strlen(expr)) {
        if (expr[index] >= '0' && expr[index] <= '9') {
            x += expr[index] - '0';
        }
        else {
            result = calculate(result, expr[index], x);
            x = 0;
        }

        ++index;
    }

    return result;
}
```

---

### Задача 3

Даден е лабиринт с **M** реда и **N** колони, където с ***0*** са означени проходимите клетки, а с ***1*** - блокираните. Да се изведе кой да е път от стартовата точка (**sty**, **stx**) до финалната (**fny**, **fnx**).

**Вход:**

На 1-вия ред на стандартния вход се въвеждат **M** и **N**. Следват **M** реда с по **N** елемента - самия лабиринт. Следват 2 реда, съдържащи стартовата позиция (**sty**, **stx**) и финалната позиция (**fny**, **fnx**).

**Изход:**

На 1-вия ред от стандартния изход да се изведе дължината **pathLen** на намерения път. Следват **pathLen** на брой реда, съдържащи (в правилен ред) координатите на клетките от пътя.

**Забележка:** Не е необходимо да е най-късия път.

### Пример:

**Вход:** <br>
3 5 <br>
00000 <br> 
01110 <br>
00000 <br>
0 1 <br>
2 2

**Изход:** <br>
5 <br>
0 0 <br>
1 0 <br>
2 0 <br>
2 1 <br>
2 2

---

### Задача 4

Даден е квадрат със страна **N**, където с **0** са маркирани солидните части, а с **1** – дупките. В квадратче с координати (**X, Y**) е излята вода. Водата се разпространява в четирите основни посоки – надолу, нагоре, наляво, надясно, с едно квадратче за единица време. 

За колко време целия квадрат ще е запълнен с вода? Ако това не е възможно, да се изведе **-1**.

**Вход:** размерност **N** и координати **X**, **Y**, последвани от **N** реда по **N** колони. Броенето започва от **0**.

### Пример:

**Вход:** <br>
5 0  1 <br>
0 1 1 0 0 <br>
1 1 0 1 0 <br>
0 1 1 1 0 <br>
0 1 0 1 0 <br>
0 0 1 1 1

**Изход:** 8

**Илюстрация на движението на водата по време:** <br>
0 1 2 0 0 <br>
3 2 0 6 0 <br>
0 3 4 5 0 <br>
0 4 0 6 0 <br>
0 0 8 7 8